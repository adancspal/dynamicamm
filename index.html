<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Virtual AMM + Anchor Price Playground</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 20px;
      background: #0f172a;
      color: #e5e7eb;
    }

    h1, h2, h3 {
      margin-top: 0;
      color: #f9fafb;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      margin-bottom: 16px;
    }

    .card {
      background: #020617;
      border-radius: 16px;
      padding: 16px 18px 18px;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
      border: 1px solid #1f2937;
    }

    label {
      display: block;
      font-size: 13px;
      margin-bottom: 4px;
      color: #9ca3af;
    }

    input, select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 14px;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #4ade80;
      box-shadow: 0 0 0 1px rgba(74, 222, 128, 0.5);
    }

    .row {
      display: flex;
      gap: 10px;
    }

    .row > div {
      flex: 1;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: transform 0.05s ease-out, box-shadow 0.05s ease-out, background 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #22c55e, #22d3ee);
      color: #020617;
      box-shadow: 0 12px 30px rgba(34, 197, 94, 0.35);
    }

    .btn-secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #374151;
    }

    .btn:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
    }

    .btn + .btn {
      margin-left: 8px;
    }

    .pill {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      background: rgba(148, 163, 184, 0.18);
      color: #e5e7eb;
    }

    .pill-good {
      background: rgba(74, 222, 128, 0.15);
      color: #bbf7d0;
    }

    .pill-bad {
      background: rgba(248, 113, 113, 0.18);
      color: #fecaca;
    }

    .state-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .state-item {
      padding: 6px 8px;
      border-radius: 12px;
      background: #020617;
      border: 1px solid #1f2937;
      font-size: 12px;
    }

    .state-item span {
      display: block;
    }

    .state-label {
      color: #9ca3af;
      font-size: 11px;
    }

    .state-value {
      font-family: "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      color: #e5e7eb;
      font-size: 12px;
      margin-top: 2px;
    }

    .muted {
      font-size: 12px;
      color: #9ca3af;
    }

    .error {
      color: #fecaca;
      background: rgba(127, 29, 29, 0.35);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      margin-top: 10px;
      border: 1px solid rgba(248, 113, 113, 0.4);
    }

    .success {
      color: #bbf7d0;
      background: rgba(22, 101, 52, 0.35);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      margin-top: 10px;
      border: 1px solid rgba(74, 222, 128, 0.5);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      margin-top: 8px;
    }

    th, td {
      padding: 6px 8px;
      border-bottom: 1px solid #1f2937;
    }

    th {
      text-align: left;
      color: #9ca3af;
      font-weight: 500;
      background: #020617;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    tbody tr:nth-child(even) {
      background: rgba(15, 23, 42, 0.6);
    }

    .history-container {
      max-height: 220px;
      overflow: auto;
      border-radius: 12px;
      border: 1px solid #1f2937;
    }

    .badge-buy {
      color: #bbf7d0;
    }

    .badge-sell {
      color: #fecaca;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Virtual AMM + Anchor Price Playground</h1>
    <p class="muted">
      Anchor is the fair price. You choose Base and Quote inventory. Virtual AMM computes a deviation multiplier; user price = anchor Ã— multiplier (plus fee).
    </p>

    <div class="grid">
      <!-- Global config and initialization -->
      <div class="card">
        <div class="row" style="align-items:center; justify-content:space-between;">
          <h2 style="margin-bottom:4px;">Market Setup</h2>
          <span class="pill">Config</span>
        </div>

        <div class="row">
          <div>
            <label for="baseSymbol">Base symbol</label>
            <input id="baseSymbol" type="text" value="TSLA" />
          </div>
          <div>
            <label for="quoteSymbol">Quote symbol</label>
            <input id="quoteSymbol" type="text" value="USDC" />
          </div>
        </div>

        <div class="row" style="margin-top:8px;">
          <div>
            <label for="anchorPrice">Anchor price (Quote per 1 Base)</label>
            <input id="anchorPrice" type="number" step="0.0000001" value="2" />
          </div>
          <div>
            <label for="feeBps">Fee (bps)</label>
            <input id="feeBps" type="number" step="1" value="10" />
          </div>
        </div>

        <h3 style="margin-top:14px;">Initial virtual reserves (inventory)</h3>
        <p class="muted">
          These are pure inventory for the virtual AMM. They do <strong>not</strong> have to match the anchor; anchor is fair price, reserves just control how strong the deviation is.
        </p>

        <div class="row">
          <div>
            <label for="initBase">Initial Base reserve (R_base)</label>
            <input id="initBase" type="number" step="0.0000001" value="100" />
          </div>
          <div>
            <label for="initQuote">Initial Quote reserve (R_quote)</label>
            <input id="initQuote" type="number" step="0.0000001" value="100" />
          </div>
        </div>

        <div style="margin-top:12px;">
          <button id="btnInit" class="btn btn-primary">
            ðŸ”„ Initialize / Reinitialize AMM
          </button>
          <button id="btnResetBaseline" class="btn btn-secondary">
            ðŸŽ¯ Reset baseline (râ‚€ from current reserves)
          </button>
        </div>

        <p class="muted" style="margin-top:10px;">
          Init sets <code>R_base</code>, <code>R_quote</code>, <code>R_base0</code>, <code>R_quote0</code>, <code>k</code>.
          Baseline price ratio is <code>râ‚€ = R_quote0 / R_base0</code>. Anchor is an external fair price used on top.
        </p>
      </div>

      <!-- Current state -->
      <div class="card">
        <div class="row" style="align-items:center; justify-content:space-between;">
          <h2 style="margin-bottom:4px;">Current State</h2>
          <span id="statusPill" class="pill-bad pill">Uninitialized</span>
        </div>

        <div class="state-grid">
          <div class="state-item">
            <span class="state-label">R_base (virtual)</span>
            <span id="stateRBase" class="state-value">â€“</span>
          </div>
          <div class="state-item">
            <span class="state-label">R_quote (virtual)</span>
            <span id="stateRQuote" class="state-value">â€“</span>
          </div>
          <div class="state-item">
            <span class="state-label">R_base0 (baseline)</span>
            <span id="stateRBase0" class="state-value">â€“</span>
          </div>
          <div class="state-item">
            <span class="state-label">R_quote0 (baseline)</span>
            <span id="stateRQuote0" class="state-value">â€“</span>
          </div>
          <div class="state-item">
            <span class="state-label">râ‚€ = R_quote0 / R_base0</span>
            <span id="stateR0" class="state-value">â€“</span>
          </div>
          <div class="state-item">
            <span class="state-label">Reserve ratio R_quote / R_base</span>
            <span id="stateRpre" class="state-value">â€“</span>
          </div>
          <div class="state-item">
            <span class="state-label">k = R_base * R_quote</span>
            <span id="stateK" class="state-value">â€“</span>
          </div>
          <div class="state-item">
            <span class="state-label">Last anchor price</span>
            <span id="stateAnchor" class="state-value">â€“</span>
          </div>
        </div>

        <p class="muted" style="margin-top:10px;">
          Anchor is independent of reserves. Reserves drive the curve price <code>P_curve</code>, which becomes a multiplier over anchor.
        </p>
      </div>
    </div>

    <div class="grid">
      <!-- Trade form -->
      <div class="card">
        <div class="row" style="align-items:center; justify-content:space-between;">
          <h2 style="margin-bottom:4px;">New Trade</h2>
          <span class="pill">Swap</span>
        </div>

        <div class="row">
          <div>
            <label for="side">Side</label>
            <select id="side">
              <option value="BUY_BASE">Buy Base with Quote</option>
              <option value="SELL_BASE">Sell Base for Quote</option>
            </select>
          </div>
          <div>
            <label id="amountInLabel" for="amountIn">Amount in Quote (amountIn)</label>
            <input id="amountIn" type="number" step="0.0000001" value="10" />
          </div>
        </div>

        <h3 style="margin-top:12px;">User protections (optional)</h3>
        <div class="row">
          <div>
            <label for="userLimitPrice">User limit price (Quote per Base)</label>
            <input id="userLimitPrice" type="number" step="0.0000001" value="" placeholder="empty = ignore" />
          </div>
          <div>
            <label for="maxSlippageBps">Max slippage (bps) vs anchor</label>
            <input id="maxSlippageBps" type="number" step="1" value="" placeholder="empty = ignore" />
          </div>
        </div>

        <div style="margin-top:12px;">
          <button id="btnTrade" class="btn btn-primary">
            ðŸš€ Execute trade
          </button>
        </div>

        <div id="tradeMessage"></div>
      </div>

      <!-- Last trade result -->
      <div class="card">
        <div class="row" style="align-items:center; justify-content:space-between;">
          <h2 style="margin-bottom:4px;">Last Trade Result</h2>
          <span class="pill">Summary</span>
        </div>

        <div id="lastTradeSummary" class="muted">
          No trades yet.
        </div>
      </div>
    </div>

    <!-- Trade history -->
    <div class="card" style="margin-top:4px;">
      <div class="row" style="align-items:center; justify-content:space-between;">
        <h2 style="margin-bottom:4px;">Trade History</h2>
        <span class="pill">Session</span>
      </div>
      <p class="muted">
        Each row shows curve price, multiplier, execution price vs anchor, and final user price including fee.
      </p>
      <div class="history-container">
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Side</th>
              <th>amountIn</th>
              <th>Î”Base (virtual)</th>
              <th>Î”Quote (virtual)</th>
              <th>P_curve</th>
              <th>m</th>
              <th>P_exec</th>
              <th>P_final</th>
              <th>Slippage (bps)</th>
            </tr>
          </thead>
          <tbody id="historyBody">
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    // --------- State ---------
    let isInitialized = false;
    let R_base = 0;
    let R_quote = 0;
    let R_base0 = 0;
    let R_quote0 = 0;
    let k = 0;
    let lastAnchorPrice = null;
    let tradeCount = 0;

    // --------- Helpers ---------
    function fmt(x, digits = 6) {
      if (x === null || x === undefined || Number.isNaN(x)) return "â€“";
      return Number(x).toFixed(digits);
    }

    function updateStateDisplay() {
      const stateRBase = document.getElementById("stateRBase");
      const stateRQuote = document.getElementById("stateRQuote");
      const stateRBase0 = document.getElementById("stateRBase0");
      const stateRQuote0 = document.getElementById("stateRQuote0");
      const stateR0 = document.getElementById("stateR0");
      const stateRpre = document.getElementById("stateRpre");
      const stateK = document.getElementById("stateK");
      const stateAnchor = document.getElementById("stateAnchor");
      const statusPill = document.getElementById("statusPill");

      if (!isInitialized) {
        statusPill.textContent = "Uninitialized";
        statusPill.className = "pill pill-bad";
        stateRBase.textContent = "â€“";
        stateRQuote.textContent = "â€“";
        stateRBase0.textContent = "â€“";
        stateRQuote0.textContent = "â€“";
        stateR0.textContent = "â€“";
        stateRpre.textContent = "â€“";
        stateK.textContent = "â€“";
        stateAnchor.textContent = "â€“";
        return;
      }

      statusPill.textContent = "Active";
      statusPill.className = "pill pill-good";

      const r0 = (R_base0 > 0) ? (R_quote0 / R_base0) : null;
      const rpre = (R_base > 0) ? (R_quote / R_base) : null;

      stateRBase.textContent = fmt(R_base);
      stateRQuote.textContent = fmt(R_quote);
      stateRBase0.textContent = fmt(R_base0);
      stateRQuote0.textContent = fmt(R_quote0);
      stateR0.textContent = fmt(r0);
      stateRpre.textContent = fmt(rpre);
      stateK.textContent = fmt(k);
      stateAnchor.textContent = lastAnchorPrice !== null ? fmt(lastAnchorPrice) : "â€“";
    }

    function setTradeMessage(text, isError = false) {
      const el = document.getElementById("tradeMessage");
      if (!text) {
        el.innerHTML = "";
        el.className = "";
        return;
      }
      el.className = isError ? "error" : "success";
      el.innerHTML = text;
    }

    function appendHistoryRow(row) {
      const tbody = document.getElementById("historyBody");
      const tr = document.createElement("tr");

      const td = (text) => {
        const el = document.createElement("td");
        el.textContent = text;
        return el;
      };

      tr.appendChild(td(row.index));
      const sideCell = td(row.side);
      sideCell.className = row.side === "BUY_BASE" ? "badge-buy" : "badge-sell";
      tr.appendChild(sideCell);
      tr.appendChild(td(fmt(row.amountIn)));
      tr.appendChild(td(fmt(row.deltaBase)));
      tr.appendChild(td(fmt(row.deltaQuote)));
      tr.appendChild(td(fmt(row.P_curve)));
      tr.appendChild(td(fmt(row.m)));
      tr.appendChild(td(fmt(row.P_exec)));
      tr.appendChild(td(fmt(row.P_final)));
      tr.appendChild(td(row.slippageBps !== null ? fmt(row.slippageBps, 2) : "â€“"));

      tbody.insertBefore(tr, tbody.firstChild);
    }

    function updateAmountInLabel() {
      const side = document.getElementById("side").value;
      const baseSymbol = document.getElementById("baseSymbol").value || "Base";
      const quoteSymbol = document.getElementById("quoteSymbol").value || "Quote";
      const label = document.getElementById("amountInLabel");

      if (side === "BUY_BASE") {
        label.textContent = `Amount in ${quoteSymbol} (amountIn)`;
      } else {
        label.textContent = `Amount in ${baseSymbol} (amountIn)`;
      }
    }

    // --------- Event handlers ---------
    document.getElementById("side").addEventListener("change", updateAmountInLabel);

    document.getElementById("btnInit").addEventListener("click", () => {
      const initBase = parseFloat(document.getElementById("initBase").value);
      const initQuote = parseFloat(document.getElementById("initQuote").value);
      const anchor = parseFloat(document.getElementById("anchorPrice").value);

      if (!Number.isFinite(initBase) || initBase <= 0 ||
          !Number.isFinite(initQuote) || initQuote <= 0) {
        setTradeMessage("Please provide positive initial reserves for Base and Quote.", true);
        return;
      }

      if (!Number.isFinite(anchor) || anchor <= 0) {
        setTradeMessage("Please provide a positive anchor price before initializing.", true);
        return;
      }

      R_base = initBase;
      R_quote = initQuote;
      R_base0 = initBase;
      R_quote0 = initQuote;
      k = R_base * R_quote;
      lastAnchorPrice = anchor;
      isInitialized = true;

      setTradeMessage("AMM initialized. Baseline set to initial virtual reserves.", false);
      updateStateDisplay();
    });

    document.getElementById("btnResetBaseline").addEventListener("click", () => {
      if (!isInitialized) {
        setTradeMessage("AMM is not initialized yet. Initialize it first.", true);
        return;
      }

      R_base0 = R_base;
      R_quote0 = R_quote;
      k = R_base * R_quote;

      setTradeMessage("Baseline reset: râ‚€ updated from current virtual reserves (anchor unchanged).", false);
      updateStateDisplay();
    });

    document.getElementById("btnTrade").addEventListener("click", () => {
      if (!isInitialized) {
        setTradeMessage("AMM is not initialized yet. Initialize it first.", true);
        return;
      }

      setTradeMessage("");

      const side = document.getElementById("side").value;
      const baseSymbol = document.getElementById("baseSymbol").value || "Base";
      const quoteSymbol = document.getElementById("quoteSymbol").value || "Quote";

      const amountInRaw = parseFloat(document.getElementById("amountIn").value);
      const anchorPriceInput = parseFloat(document.getElementById("anchorPrice").value);
      const feeBpsInput = parseFloat(document.getElementById("feeBps").value);
      const userLimitPriceInput = document.getElementById("userLimitPrice").value;
      const maxSlippageBpsInput = document.getElementById("maxSlippageBps").value;

      if (!Number.isFinite(amountInRaw) || amountInRaw <= 0) {
        setTradeMessage("Please enter a positive amountIn.", true);
        return;
      }

      const P_anchor = Number.isFinite(anchorPriceInput) && anchorPriceInput > 0
        ? anchorPriceInput
        : (lastAnchorPrice || null);

      if (P_anchor === null) {
        setTradeMessage("No valid anchor price available. Set one in the Market Setup section.", true);
        return;
      }

      lastAnchorPrice = P_anchor; // keep latest
      const feeBps = Number.isFinite(feeBpsInput) && feeBpsInput >= 0 ? feeBpsInput : 0;
      const feeFactor = 1 + feeBps / 10000;

      const r0 = (R_base0 > 0) ? (R_quote0 / R_base0) : null;
      if (!(r0 > 0)) {
        setTradeMessage("Baseline ratio râ‚€ is invalid. Try reinitializing or resetting baseline.", true);
        return;
      }

      let R_base_new, R_quote_new;
      let deltaBase_virtual, deltaQuote_virtual;
      let P_curve;

      if (side === "SELL_BASE") {
        // User sends Î”Base (amountIn), receives Î”Quote
        const deltaBaseIn = amountInRaw;
        const newRBase = R_base + deltaBaseIn;
        if (newRBase <= 0) {
          setTradeMessage("Resulting R_base would be non-positive.", true);
          return;
        }
        const newRQuote = k / newRBase;
        const deltaQuoteOut = R_quote - newRQuote;

        if (deltaQuoteOut <= 0) {
          setTradeMessage("AMM would output non-positive quote (virtual). Trade rejected.", true);
          return;
        }

        R_base_new = newRBase;
        R_quote_new = newRQuote;
        deltaBase_virtual = deltaBaseIn;
        deltaQuote_virtual = deltaQuoteOut;
        P_curve = deltaQuoteOut / deltaBaseIn; // Quote per Base (virtual avg price)
      } else {
        // BUY_BASE: user sends Î”Quote (amountIn), receives Î”Base
        const deltaQuoteIn = amountInRaw;
        const newRQuote = R_quote + deltaQuoteIn;
        if (newRQuote <= 0) {
          setTradeMessage("Resulting R_quote would be non-positive.", true);
          return;
        }
        const newRBase = k / newRQuote;
        const deltaBaseOut = R_base - newRBase;

        if (deltaBaseOut <= 0) {
          setTradeMessage("AMM would output non-positive base (virtual). Trade rejected.", true);
          return;
        }

        R_base_new = newRBase;
        R_quote_new = newRQuote;
        deltaBase_virtual = deltaBaseOut;
        deltaQuote_virtual = deltaQuoteIn;
        P_curve = deltaQuoteIn / deltaBaseOut; // Quote per Base (virtual avg price)
      }

      // Multiplier and execution price
      const m = P_curve / r0;
      const P_exec = P_anchor * m;

      // User-facing amounts (based on P_exec, then apply fee)
      let deltaBase_user, deltaQuote_user, P_final;
      if (side === "BUY_BASE") {
        const quoteInUser = amountInRaw;
        const baseOutPreFee = quoteInUser / P_exec;
        const baseOutUser = baseOutPreFee / feeFactor;
        deltaBase_user = baseOutUser;
        deltaQuote_user = quoteInUser;
        P_final = deltaQuote_user / deltaBase_user; // effective user price (incl. fee)
      } else {
        const baseInUser = amountInRaw;
        const quoteOutPreFee = baseInUser * P_exec;
        const quoteOutUser = quoteOutPreFee / feeFactor;
        deltaBase_user = baseInUser;
        deltaQuote_user = quoteOutUser;
        P_final = deltaQuote_user / deltaBase_user;
      }

      // Slippage vs anchor
      const P_ref = P_anchor;
      let slippageBps = null;
      if (P_ref > 0) {
        slippageBps = Math.abs((P_final - P_ref) / P_ref) * 10000;
      }

      // Enforce userLimitPrice if provided
      if (userLimitPriceInput.trim() !== "") {
        const userLimitPrice = parseFloat(userLimitPriceInput);
        if (!(Number.isFinite(userLimitPrice) && userLimitPrice > 0)) {
          setTradeMessage("Invalid user limit price.", true);
          return;
        }
        if (side === "BUY_BASE") {
          if (P_final > userLimitPrice) {
            setTradeMessage(
              `Final price ${fmt(P_final)} exceeds user limit price ${fmt(userLimitPrice)}. Trade reverted.`,
              true
            );
            return;
          }
        } else {
          if (P_final < userLimitPrice) {
            setTradeMessage(
              `Final price ${fmt(P_final)} is below user limit price ${fmt(userLimitPrice)}. Trade reverted.`,
              true
            );
            return;
          }
        }
      }

      // Enforce maxSlippageBps if provided
      if (maxSlippageBpsInput.trim() !== "" && slippageBps !== null) {
        const maxSlippage = parseFloat(maxSlippageBpsInput);
        if (!(Number.isFinite(maxSlippage) && maxSlippage >= 0)) {
          setTradeMessage("Invalid max slippage bps.", true);
          return;
        }
        if (slippageBps > maxSlippage) {
          setTradeMessage(
            `Slippage ${fmt(slippageBps, 2)} bps exceeds max allowed ${fmt(maxSlippage, 2)} bps. Trade reverted.`,
            true
          );
          return;
        }
      }

      // Commit virtual reserves
      R_base = R_base_new;
      R_quote = R_quote_new;
      k = R_base * R_quote;
      isInitialized = true;
      updateStateDisplay();

      tradeCount += 1;

      const sideText = side === "BUY_BASE"
        ? `Buy ${baseSymbol} with ${quoteSymbol}`
        : `Sell ${baseSymbol} for ${quoteSymbol}`;

      // Last trade summary
      const summaryEl = document.getElementById("lastTradeSummary");
      summaryEl.innerHTML = `
        <div>
          <div><strong>Side:</strong> ${sideText}</div>
          <div><strong>amountIn:</strong> ${fmt(amountInRaw)}</div>
          <div style="margin-top:6px;">
            <strong>Virtual AMM (inventory only):</strong><br/>
            Î”Base (virtual): ${fmt(deltaBase_virtual)}<br/>
            Î”Quote (virtual): ${fmt(deltaQuote_virtual)}<br/>
            P_curve = Î”Quote / Î”Base = <code>${fmt(P_curve)}</code> ${quoteSymbol} per ${baseSymbol}<br/>
            râ‚€ = <code>${fmt(r0)}</code><br/>
            Multiplier m = P_curve / râ‚€ = <code>${fmt(m)}</code><br/>
          </div>
          <div style="margin-top:6px;">
            <strong>Anchor + deviation:</strong><br/>
            P_anchor = <code>${fmt(P_anchor)}</code><br/>
            P_exec = P_anchor * m = <code>${fmt(P_exec)}</code><br/>
          </div>
          <div style="margin-top:6px;">
            <strong>User amounts (incl. fee ${fmt(feeBps,2)} bps):</strong><br/>
            User Î”Base: ${fmt(deltaBase_user)} ${baseSymbol}<br/>
            User Î”Quote: ${fmt(deltaQuote_user)} ${quoteSymbol}<br/>
            Effective user price P_final = <code>${fmt(P_final)}</code> ${quoteSymbol} per ${baseSymbol}<br/>
            Slippage vs anchor = ${slippageBps !== null ? fmt(slippageBps, 2) : "â€“"} bps
          </div>
        </div>
      `;

      // History row
      appendHistoryRow({
        index: tradeCount,
        side,
        amountIn: amountInRaw,
        deltaBase: deltaBase_virtual,
        deltaQuote: deltaQuote_virtual,
        P_curve,
        m,
        P_exec,
        P_final,
        slippageBps
      });

      setTradeMessage("Trade executed successfully.", false);
    });

    // Initial label
    updateAmountInLabel();
    updateStateDisplay();
  </script>
</body>
</html>
